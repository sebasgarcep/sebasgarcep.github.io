<!DOCTYPE html><html lang="en" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="Counting Primes Really Fast" /><meta property="og:locale" content="en" /><meta name="description" content="Suppose you are given a very large number, for example $n = 10^{12}$, and you wish to know how many numbers equal to or less than $n$ are prime. This is the prime counting function, normally denotes as $\pi(n)$. In this article we will explore some of the methods to efficiently calculate $\pi(n)$, and we will benchmark each in Rust." /><meta property="og:description" content="Suppose you are given a very large number, for example $n = 10^{12}$, and you wish to know how many numbers equal to or less than $n$ are prime. This is the prime counting function, normally denotes as $\pi(n)$. In this article we will explore some of the methods to efficiently calculate $\pi(n)$, and we will benchmark each in Rust." /><link rel="canonical" href="https://sebasgarcep.github.io/posts/counting-primes-really-fast/" /><meta property="og:url" content="https://sebasgarcep.github.io/posts/counting-primes-really-fast/" /><meta property="og:site_name" content="Sebastian Garrido" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-06-28T00:00:00-05:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Counting Primes Really Fast" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"headline":"Counting Primes Really Fast","dateModified":"2022-01-04T10:57:46-05:00","datePublished":"2021-06-28T00:00:00-05:00","description":"Suppose you are given a very large number, for example $n = 10^{12}$, and you wish to know how many numbers equal to or less than $n$ are prime. This is the prime counting function, normally denotes as $\\pi(n)$. In this article we will explore some of the methods to efficiently calculate $\\pi(n)$, and we will benchmark each in Rust.","url":"https://sebasgarcep.github.io/posts/counting-primes-really-fast/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://sebasgarcep.github.io/posts/counting-primes-really-fast/"},"@context":"https://schema.org"}</script><title>Counting Primes Really Fast | Sebastian Garrido</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Sebastian Garrido"><meta name="application-name" content="Sebastian Garrido"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/profile.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sebastian Garrido</a></div><div class="site-subtitle font-italic">Data Engineer</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/sebasgarcep" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/sebastian-garrido-cepeda-20b090152/" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sebasgarcep','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Counting Primes Really Fast</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <img data-src="/assets/img/2021-06-28-counting-primes-really-fast/chalkboard.jpg" class="preview-img bg" alt="Chalkboard" data-proofer-ignore><h1 data-toc-skip>Counting Primes Really Fast</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/sebasgarcep">Sebastian Garrido</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" date="2021-06-28 00:00:00 -0500" data-toggle="tooltip" data-placement="bottom" title="Mon, Jun 28, 2021, 12:00 AM -0500" >Jun 28, 2021</em> </span> <span> Updated <em class="timeago" date="2022-01-04 10:57:46 -0500 " data-toggle="tooltip" data-placement="bottom" title="Tue, Jan 4, 2022, 10:57 AM -0500" >Jan 4, 2022</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3574 words"> <em>19 min</em> read</span></div></div></div><div class="post-content"><p>Suppose you are given a very large number, for example $n = 10^{12}$, and you wish to know how many numbers equal to or less than $n$ are prime. This is the prime counting function, normally denotes as $\pi(n)$. In this article we will explore some of the methods to efficiently calculate $\pi(n)$, and we will benchmark each in Rust.</p><h1 id="checking-every-number-up-to-n-for-primality">Checking every number up to $n$ for primality</h1><p>Let’s write a naive implementation that we will use as a baseline. Of course, the first approach would be to test the primality of each number from $2$ to $n$. First, let’s write a naive implementation for <code class="language-plaintext highlighter-rouge">is_prime</code>:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">d</span> <span class="n">in</span> <span class="mi">2</span><span class="o">..</span><span class="n">x</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Now, counting primes is as simple as iterating over the numbers that can be prime and testing each one:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">count</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="n">x</span> <span class="n">in</span> <span class="mi">2</span><span class="o">..</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>As you might expect, this function does terribly:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Begun testing the naive implementation with n = 10^5.
The amount of prime numbers that are less than or equal to 10^5 is 9592.
Elapsed: 1.03s
Finished testing the naive implementation with n = 10^5.
</pre></table></code></div></div><p>I couldn’t even get it to finish calculating $n = 10^6$ in under a minute.</p><h1 id="using-the-sieve-of-eratosthenes">Using the Sieve of Eratosthenes</h1><p>A better option than the naive implementation is the Sieve of Eratosthenes. There is a nice graphic on its <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Wikipedia entry</a> explaining how it works, so I won’t go into detail. First of all, note that it is clearly faster than checking each prime as the operations are simpler (just addition and multiplication instead of the modulus operator). The problem with this algorithm is that you would need a flag for each number to indicate whether it is prime or not. For large enough $n$ this is untenable, as you will soon run out of memory, or the memory will take too long to allocate. Still, you could use the Sieve of Eratosthenes to rapidly compute the primes up to a given limit.</p><p>A naive implementation of the sieve in Rust looks like:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">count</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">flags</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">_</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">n</span> <span class="p">{</span>
        <span class="n">flags</span><span class="nf">.push</span><span class="p">(</span><span class="k">true</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">flags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>

    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">n</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">flags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">for</span> <span class="n">m</span> <span class="nf">in</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">..</span><span class="n">n</span><span class="p">)</span><span class="nf">.step_by</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">flags</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>A benchmark using $n = 10^6$ proves this function to be much faster than the naive implementation:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Begun testing the sieve implementation with n = 10^6.
The amount of prime numbers that are less than or equal to 10^6 is 78498.
Elapsed: 6.86ms
Finished testing the sieve implementation with n = 10^6.
</pre></table></code></div></div><p>Sadly, it starts to falters at around $n = 10^9$:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Begun testing the sieve implementation with n = 10^9.
The amount of prime numbers that are less than or equal to 10^9 is 50847534.
Elapsed: 16.53s
Finished testing the sieve implementation with n = 10^9.
</pre></table></code></div></div><p>I couldn’t get it to run for $n = 10^{10}$ in under a minute.</p><p>This does not imply that the sieve is useless for our purposes of calculating $\pi(10^{12})$. In fact, we will be using it in the next few sections.</p><h1 id="without-knowing-all-the-primes-legendres-formula">Without knowing all the primes (Legendre’s Formula)</h1><p>To reduce the amount of memory required for our computation we will use Legendre’s Formula. It essentially allows you to count primes up to $n$, while only knowing the primes up to $\sqrt{n}$. Now let’s proceed to prove it.</p><p>Let $\phi(n, a)$ be the amount of numbers less than or equal to $n$, which are not divisible by the first $a$ primes. Then we can calculate $\phi(n, a)$ using the inclusion-exclusion principle:</p>\[\phi(n, a) = n - \sum_{p_i} \lfloor \frac{n}{p_i} \rfloor + \sum_{p_i &lt; p_j} \lfloor \frac{n}{p_i p_j} \rfloor - \sum_{p_i &lt; p_j &lt; p_k} \lfloor \frac{n}{p_i p_j p_k} \rfloor + \dots\]<p>where all the $i, j, k, \dots \leq a$.</p><p>Now, let’s prove the following fact: suppose $p \leq n$. Then either $p$ is $1$, it has a divisor $d \leq \sqrt{n}$ or it is prime. If $p = 1$, we are done. If $p \leq \sqrt{n}$ then it has a divisor $d \leq \sqrt{n}$, where $d = p$. Now let $p &gt; \sqrt{n}$. We will now proceed by contradiction. Suppose $d$ is the smallest divisor of $p$ larger than $1$. Assume said divisor is larger than $\sqrt{n}$. Clearly $p/d$ is also a divisor of $p$ and thus $p/d \geq d &gt; \sqrt{n}$. But $p = p/d \times d &gt; \sqrt{n} × \sqrt{n} = n$, which is impossible. Therefore $d$ must not exceed $\sqrt{n}$.</p><p>From the previous fact we have that:</p>\[\phi(n, \pi(\sqrt{n})) = 1 + \pi(n) - \pi(\sqrt{n})\]<p>Which can be rearranged to find $\pi(n)$. This is Legendre’s Formula.</p><p>Now let’s write an implementation for Legendre’s Formula. First we need to find all primes up to $\sqrt{n}$. This can be done in multiple ways, but the sieve of Eratosthenes is particularly effective and simple:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">isqrt</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="k">as</span> <span class="nb">f64</span><span class="p">)</span><span class="nf">.sqrt</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Calculate primes up to isqrt(n)</span>
<span class="k">fn</span> <span class="nf">get_primes</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="nf">isqrt</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">capacity</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">l</span> <span class="k">as</span> <span class="nb">f64</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">l</span> <span class="k">as</span> <span class="nb">f64</span><span class="p">)</span><span class="nf">.ln</span><span class="p">())</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">primes</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">capacity</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">flags</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">_</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">l</span> <span class="p">{</span>
        <span class="n">flags</span><span class="nf">.push</span><span class="p">(</span><span class="k">true</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">flags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>

    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">l</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">flags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">for</span> <span class="n">m</span> <span class="nf">in</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">..</span><span class="n">l</span><span class="p">)</span><span class="nf">.step_by</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">flags</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">primes</span><span class="nf">.push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">primes</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Notice that we preallocate $1.5 \frac{n}{log n}$ as the capacity for the <code class="language-plaintext highlighter-rouge">primes</code> vector. This is because $\pi(n)$ is upper bounded by this quantity, as shown on <a href="https://en.wikipedia.org/wiki/Prime-counting_function">Wikipedia</a>.</p><p>And now we need to calculate the sum. Because Legendre’s Formula is an infinite sum, we need to find a stopping point. We can get a clear cutoff point by noting that, in each sum, the smallest divisor is the product of the first $m$ primes. At some point this product is going to get larger than $n$, at which point all terms in the sum will be $0$. This logic is implemented with the function <code class="language-plaintext highlighter-rouge">get_max_depth</code>:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">get_max_depth</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">primes</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">max_depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">min_product</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="n">max_depth</span> <span class="o">&lt;</span> <span class="n">primes</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">min_product</span> <span class="o">*=</span> <span class="n">primes</span><span class="p">[</span><span class="n">max_depth</span><span class="p">];</span>
        <span class="k">if</span> <span class="n">min_product</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="p">{</span> <span class="k">break</span><span class="p">;</span> <span class="p">}</span>
        <span class="n">max_depth</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">max_depth</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Finally, we need to implement the function that calculates each of the sums. Because the number of primes that you must use in each sum is not fixed, we need to implement this function using recursion. I don’t want to go into details of how to do that, so this is what the function ends up looking like:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">calculate_sum</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">primes</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">depth</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">maybe_last_index</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">product</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">depth</span> <span class="o">&lt;</span> <span class="n">level</span> <span class="p">{</span> <span class="k">return</span> <span class="n">n</span> <span class="o">/</span> <span class="n">product</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">start_index</span> <span class="o">=</span> <span class="k">match</span> <span class="n">maybe_last_index</span> <span class="p">{</span>
        <span class="nf">Some</span><span class="p">(</span><span class="n">last_index</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">last_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nb">None</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="n">end_index</span> <span class="o">=</span> <span class="n">primes</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="n">depth</span> <span class="o">+</span> <span class="n">level</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">index</span> <span class="n">in</span> <span class="n">start_index</span><span class="o">..</span><span class="n">end_index</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">next_level</span> <span class="o">=</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">next_last_index</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">next_product</span> <span class="o">=</span> <span class="n">product</span> <span class="o">*</span> <span class="n">primes</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
        <span class="k">if</span> <span class="n">next_product</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="p">{</span> <span class="k">break</span><span class="p">;</span> <span class="p">}</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="nf">calculate_sum</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">primes</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">next_level</span><span class="p">,</span> <span class="n">next_last_index</span><span class="p">,</span> <span class="n">next_product</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Finally let’s write the <code class="language-plaintext highlighter-rouge">count</code> function, which is now trivial to implement:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">count</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">result</span><span class="p">:</span> <span class="nb">isize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">primes</span> <span class="o">=</span> <span class="nf">get_primes</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">max_depth</span> <span class="o">=</span> <span class="nf">get_max_depth</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">primes</span><span class="p">);</span>
    
    <span class="c1">// Use Legendre's Formula</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="n">primes</span><span class="nf">.len</span><span class="p">()</span> <span class="k">as</span> <span class="nb">isize</span><span class="p">;</span>
    <span class="n">result</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">for</span> <span class="n">depth</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="p">(</span><span class="n">max_depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">term</span> <span class="o">=</span> <span class="nf">calculate_sum</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">primes</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="nb">isize</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">term</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">-=</span> <span class="n">term</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">result</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Benchmarks show us that Legendre’s formula is faster than the Sieve of Eratosthenes for $n = 10^9$:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Begun testing the legendre implementation with n = 10^9.
The amount of prime numbers that are less than or equal to 10^9 is 50847534.
Elapsed: 4.29s
Finished testing the legendre implementation with n = 10^9.
</pre></table></code></div></div><p>Sadly, Legendre’s formula scales poorly. With $n = 10^{10}$ we almost reached the minute mark:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Begun testing the legendre implementation with n = 10^10.
The amount of prime numbers that are less than or equal to 10^10 is 455052511.
Elapsed: 55.34s
Finished testing the legendre implementation with n = 10^10.
</pre></table></code></div></div><p>so it does not make sense to attempt $n = 10^{12}$.</p><p>This failure to scale is due to the fact Legendre’s formula has to iterate over millions of choices of prime multiplications. Thankfully, our next approach will get rid of this problem.</p><h1 id="meissellehmers-algorithm">Meissel–Lehmer’s algorithm</h1><p>Now comes the interesting part of the post. In <a href="https://projecteuclid.org/download/pdf_1/euclid.ijm/1255455259">this article</a> D. H. Lehmer introduces a very efficient formula for computing $\pi(n)$. Let’s prove it.</p><p>Let $P_k(n, a)$ be the amount of numbers less than or equal to $n$, which are not divisible by any of the first $a$ primes and which have exactly $k$ prime factors. Then:</p>\[\begin{equation} \phi(n, a) = \sum_{k = 0}^{r - 1} P_k(n, a) \end{equation}\]<p>for some finite $r$, as at some point the product of enough primes must be larger than $n$.</p><p>Note that:</p>\[\begin{equation} P_1(n, a) = \pi(n) - a \end{equation}\]<p>Joining $(1)$ and $(2)$ and using the fact that $P_0(n, a) = 1$ we get:</p>\[\pi(n) = a - 1 + \phi(n, a) - \sum_{k = 2}^{r - 1} P_k(n, a)\]<p>And with the right choice of $a$, and an efficient method to calculate $\phi(n, a)$ and the $P_k(n, a)$, we have an efficient formula for $\pi(n)$.</p><p>Let’s start by computing $P_2(n, a)$. Let $p_i$ be the $i$-th prime. Then:</p>\[P_2(n, a) = \sum_{p_i p_j \leq n} 1\] \[P_2(n, a) = \sum_{p_a &lt; p_i \leq n / p_i} \sum_{p_i \leq p_j \leq n / p_i} 1\] \[P_2(n, a) = \sum_{p_a &lt; p_i \leq \sqrt{n}} \sum_{p_i \leq p_j \leq n / p_i} 1\] \[P_2(n, a) = \sum_{p_a &lt; p_i \leq \sqrt{n}} \{ \pi(n / p_i) - (i - 1) \}\]<p>Now let $b = \pi(\sqrt{n})$ and $c = \pi(\sqrt[3]{n})$. Then we can rewrite the above as follows:</p>\[P_2(n, a) = \sum_{p_a &lt; p_i \leq \sqrt{n}} \{ \pi(n / p_i) - (i - 1) \}\] \[P_2(n, a) = \sum_{a &lt; i \leq b} \{ \pi(n / p_i) - (i - 1) \}\] \[P_2(n, a) = \sum_{a &lt; i \leq b} \pi(n / p_i) - \sum_{a &lt; i \leq b} (i - 1)\] \[\begin{equation} P_2(n, a) = \sum_{a &lt; i \leq b} \pi(n / p_i) - \frac{1}{2} (b - a) (b + a - 1) \\ \end{equation}\]<p>Now for $k = 3$, a similar procedure yields:</p>\[P_3(n, a) = \sum_{p_i p_j p_l \leq n} 1\] \[P_3(n, a) = \sum_{p_a &lt; p_i \leq n / p_i^2} \sum_{p_i \leq p_j \leq n / p_i p_j} \sum_{p_j \leq p_l \leq n / p_i p_j} 1\] \[P_3(n, a) = \sum_{p_a &lt; p_i \leq \sqrt[3]{n}} \sum_{p_i \leq p_j \leq (n / p_i)^{1/2}} \sum_{p_j \leq p_l \leq n / p_i p_j} 1\] \[P_3(n, a) = \sum_{a &lt; i \leq c} \sum_{i \leq j \leq b_i} \sum_{j \leq l \leq \pi(n / p_i p_j)} 1\] \[\begin{equation} P_3(n, a) = \sum_{a &lt; i \leq c} \sum_{i \leq j \leq b_i} \{ \pi(n / p_i p_j) - (j - 1) \} \end{equation}\]<p>where $b_i = \pi((n / p_i)^{1/2})$.</p><p>Now let $a = \pi(n^{1/k})$. Choose $k$ or more primes larger than $p_a$. Then the product of those primes is larger than $n$. Therefore $P_k(n, a) = 0, P_{k + 1}(n, a) = 0, : \dots$. Thus, we can derive several distinct formulas through the choice of $a$.</p><p>If we set $a = b = \pi(\sqrt{n})$, we get $\pi(n) = b - 1 + \phi(n, b)$, which is Legendre’s formula.</p><p>If we set $a = c = \pi(\sqrt[3]{n})$ we get $\pi(n) = c - 1 + \phi(n, c) - P_2(n, c)$ or equivalently from plugging $(3)$:</p>\[\begin{equation} \pi(n) = \phi(n, c) + \frac{1}{2} (b + c - 2) (b - c + 1) - \sum_{c &lt; i \leq b} \pi(n / p_i) \end{equation}\]<p>which is Meissel’s formula.</p><p>But the choice of $a$ we are interested in is $a = \pi(n^{1 / 4})$. With this choice the formula expands to also include $P_3(n, a)$ as follows:</p>\[\begin{equation} \pi(n) = \phi(n, a) + \frac{1}{2} (b + a - 2) (b - a + 1) - \sum_{a &lt; i \leq b} \pi(n / p_i) - \sum_{a &lt; i \leq c} \sum_{i \leq j \leq b_i} \{ \pi(n / p_i p_j) - (j - 1) \} \end{equation}\]<p>which is Meissel-Lehmer’s formula. Essentially, it is a recursive version of the prime counting function, and therefore we can speed up the computation by knowing the values of $\pi$ up to a large enough $n$ using the other algorithms. Now let’s find a way to calculate $\phi(n, a)$ efficiently. First notice the following recursion:</p>\[\begin{equation} \phi(n, a) = \phi(n, a - 1) - \phi(n / p_a, a - 1) \end{equation}\]<p>To prove that this is true, note that the amount of numbers that are divisible by $p_a$ but not by $p_1, p_2, \dots, p_{a - 1}$ is given by $\phi(n, a - 1) - \phi(n, a)$. On the other hand, this amount can be expressed as:</p>\[= |\{ \: x \: | \: x = p_a x' \leq n, p_1, p_2, \dots, p_{a - 1} \nmid x' \: \}|\] \[= |\{ \: x' \: | \: x' \leq n / p_a, p_1, p_2, \dots, p_{a - 1} \nmid x' \: \}|\] \[= \phi(n / p_a, a - 1)\]<p>which proves the recursion. Before using the recursion, let’s prove a few base cases:</p><p><em>Case 1</em>: $\phi(n, 0) = n$. This follows directly from the definition.</p><p><em>Case 2</em>: $\phi(n, 1) = n - \lfloor n / 2 \rfloor$. These are the numbers that are not divisble by $2$.</p><p><em>Case 3</em>: $\phi(n, 2) = n - \lfloor n / 2 \rfloor - \lfloor n / 3 \rfloor + \lfloor n / 6 \rfloor$. This follows from the inclusion-exclusion principle using the primes $2$ and $3$.</p><p><em>Case 4</em>: If $n \leq p_a$, then $\phi(n, a) = 1$. Clearly, all $x \leq n$ are divisible by one of $p_1, p_2, \dots, p_a$, except for the number $1$.</p><p>With the base cases out of the way let’s write an expansion for $\phi(n, a)$ using the recursion formula:</p>\[\phi(n, a) = \phi(n, a - 1) - \phi(n / p_a, a - 1)\] \[\phi(n, a) = \phi(n, a - 2) - \phi(n / p_a, a - 1) - \phi(n / p_{a - 1}, a - 2)\] \[\dots\] \[\begin{equation} \phi(n, a) = \phi(n, 2) - \sum_{i = 3}^a \phi(n / p_i, i - 1) \end{equation}\]<p>And with that we have all the parts we need to begin implementing Meissel-Lehmer formula.</p><p>To begin implementing, first we need a list of all primes up to $b$, and a way to calculate $\pi(n)$, for “small” values of $n$. Finding the primes can be done using the Sieve of Eratosthenes, and once we have the primes we can perform binary search on the list of primes to calculate $\pi(n)$ up to the limit we used to calculate the primes. Our implementation looks like this:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">PrimeTable</span> <span class="p">{</span>
    <span class="n">limit</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">primes</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span> 
<span class="p">}</span>

<span class="k">impl</span> <span class="n">PrimeTable</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">limit</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">PrimeTable</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">capacity</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">limit</span> <span class="k">as</span> <span class="nb">f64</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">limit</span> <span class="k">as</span> <span class="nb">f64</span><span class="p">)</span><span class="nf">.ln</span><span class="p">())</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">primes</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">capacity</span><span class="p">);</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">flags</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">limit</span><span class="p">);</span>
        <span class="k">for</span> <span class="n">_</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">limit</span> <span class="p">{</span>
            <span class="n">flags</span><span class="nf">.push</span><span class="p">(</span><span class="k">true</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">flags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>

        <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">limit</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">flags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">for</span> <span class="n">m</span> <span class="nf">in</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">..</span><span class="n">limit</span><span class="p">)</span><span class="nf">.step_by</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">flags</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">primes</span><span class="nf">.push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">PrimeTable</span> <span class="p">{</span> <span class="n">limit</span><span class="p">,</span> <span class="n">primes</span> <span class="p">};</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_prime_count</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="k">self</span><span class="py">.limit</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">None</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">end</span> <span class="o">=</span> <span class="k">self</span><span class="py">.primes</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">middle</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
            <span class="k">if</span> <span class="k">self</span><span class="py">.primes</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="p">{</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">middle</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">middle</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">end</span> <span class="p">||</span> <span class="k">self</span><span class="py">.primes</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_prime</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">self</span><span class="py">.primes</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Notice that this table of primes can be reused in the implementation of the recursive version of $\phi(n, a)$, as that function requires a list of primes. Our implementation of $phi$ follows trivially from $(8)$ and the base cases:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">phi</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">table</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">PrimeTable</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">table</span><span class="nf">.get_prime</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">result</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">6</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">3</span><span class="o">..</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">-=</span> <span class="nf">phi</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="n">table</span><span class="nf">.get_prime</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>We need a way to calculate the integer $n$-th root of a number. For our purposes, we used the following implementation:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">integer_nth_root</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">f64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="k">as</span> <span class="nb">f64</span><span class="p">)</span><span class="nf">.powf</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">r</span><span class="p">)</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Because <code class="language-plaintext highlighter-rouge">f64</code> is not an “exact” type, this implementation may fail for some inputs. Nevertheless, it is good enough for the scale at which we are working.</p><p>Finally, Meissel-Lehmer’s implementation follows trivially from $(6)$:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">meissel_lehmer</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">table</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">PrimeTable</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">=</span> <span class="n">table</span><span class="nf">.get_prime_count</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nf">meissel_lehmer</span><span class="p">(</span><span class="nf">integer_nth_root</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="nf">meissel_lehmer</span><span class="p">(</span><span class="nf">integer_nth_root</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="nf">meissel_lehmer</span><span class="p">(</span><span class="nf">integer_nth_root</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">phi</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">b</span> <span class="o">+</span> <span class="n">a</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

    <span class="c1">// Calculate P_2</span>
    <span class="k">for</span> <span class="n">i</span> <span class="nf">in</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">..</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">-=</span> <span class="nf">meissel_lehmer</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="n">table</span><span class="nf">.get_prime</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Calculate P_3</span>
    <span class="k">for</span> <span class="n">i</span> <span class="nf">in</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">..</span><span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">b_i</span> <span class="o">=</span> <span class="nf">meissel_lehmer</span><span class="p">(</span><span class="nf">integer_nth_root</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="n">table</span><span class="nf">.get_prime</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mf">2.0</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">);</span>
        <span class="k">for</span> <span class="n">j</span> <span class="n">in</span> <span class="n">i</span><span class="o">..</span><span class="p">(</span><span class="n">b_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">denominator</span> <span class="o">=</span> <span class="n">table</span><span class="nf">.get_prime</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">table</span><span class="nf">.get_prime</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
            <span class="n">result</span> <span class="o">-=</span> <span class="nf">meissel_lehmer</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="n">denominator</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>With all of these parts, our <code class="language-plaintext highlighter-rouge">count</code> function only needs to initialize a <code class="language-plaintext highlighter-rouge">PrimeTable</code>, and use <code class="language-plaintext highlighter-rouge">meissel_lehmer</code> on the given input.</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">count</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">limit</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nf">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nn">usize</span><span class="p">::</span><span class="nf">pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">9</span><span class="p">));</span>
    <span class="k">let</span> <span class="n">prime_table</span> <span class="o">=</span> <span class="nn">PrimeTable</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">limit</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">meissel_lehmer</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prime_table</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Because our initial problem is calculating $\pi(10^{12})$, we chose to calculate the prime list up to $10^9$, even though we only needed to do so up to $10^6$. This reduces the number of <code class="language-plaintext highlighter-rouge">meissel_lehmer</code> calls, which helps speed up the computation.</p><p>Because our implementation essentially uses the sieve algorithm to calculate primes up to $n = 10^9$, we know it will take at least ~15s to finish. Let’s benchmark $n = 10^{10}$:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Begun testing the meissel_lehmer implementation with n = 10^10.
The amount of prime numbers that are less than or equal to 10^10 is 455052511.
Elapsed: 16.09s
Finished testing the meissel_lehmer implementation with n = 10^10.
</pre></table></code></div></div><p>Notice that it does not take much to finish after the 15s mark. Let’s see if this extends all the way up to $n = 10^{12}$:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Begun testing the meissel_lehmer implementation with n = 10^12.
The amount of prime numbers that are less than or equal to 10^12 is 37607912018.
Elapsed: 18.97s
Finished testing the meissel_lehmer implementation with n = 10^12.
</pre></table></code></div></div><p>And it does!</p><h1 id="conclusion">Conclusion</h1><p>In this post we’ve proven and implemented an efficient method for calculating $\pi(n)$ for large enough $n$. Hopefully the reader has learned a new thing or two in this post!</p><p>If you want to check out the code we used, head over to my <a href="https://github.com/sebasgarcep/counting-primes-really-fast">Github</a>.</p></div><div class="post-tail-wrapper text-muted"><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/mathematics/" class="post-tag no-text-decoration" >Mathematics</a> <a href="/tags/rust/" class="post-tag no-text-decoration" >Rust</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Counting Primes Really Fast - Sebastian Garrido&url=https://sebasgarcep.github.io/posts/counting-primes-really-fast/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Counting Primes Really Fast - Sebastian Garrido&u=https://sebasgarcep.github.io/posts/counting-primes-really-fast/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Counting Primes Really Fast - Sebastian Garrido&url=https://sebasgarcep.github.io/posts/counting-primes-really-fast/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://sebasgarcep.github.io/posts/counting-primes-really-fast/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recent Update</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/from-zero-to-data-ready-part-1/">From Zero to Data-Ready (Part 1): Exploratory Data Analysis</a><li><a href="/posts/from-zero-to-data-ready-part-2/">From Zero to Data-Ready (Part 2): Building a SQL Data Warehouse</a><li><a href="/posts/from-zero-to-data-ready-part-3/">From Zero to Data-Ready (Part 3): Writing Test Driven ETLs using Python</a><li><a href="/posts/from-zero-to-data-ready-part-4/">From Zero to Data-Ready (Part 4): Building Analytics Dashboards using CubeJS and React</a><li><a href="/posts/counting-primes-really-fast/">Counting Primes Really Fast</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/data-engineering/">Data Engineering</a> <a class="post-tag" href="/tags/from-zero-to-data-ready/">From Zero to Data-Ready</a> <a class="post-tag" href="/tags/retail-project/">Retail Project</a> <a class="post-tag" href="/tags/mathematics/">Mathematics</a> <a class="post-tag" href="/tags/postgres/">Postgres</a> <a class="post-tag" href="/tags/python/">Python</a> <a class="post-tag" href="/tags/rust/">Rust</a> <a class="post-tag" href="/tags/sql/">SQL</a> <a class="post-tag" href="/tags/cubejs/">CubeJS</a> <a class="post-tag" href="/tags/data-assimilation/">Data Assimilation</a></div></div></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/kalman-filter-tutorial/"><div class="card-body"> <em class="timeago small" date="2022-01-08 00:00:00 -0500" >Jan 8, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Understanding the Kalman Filter</h3><div class="text-muted small"><p> Society depends on having correct estimates of what may happen. Whether it is the climate or traffic, humans have built models of reality which help us make better decisions. But any model is bound...</p></div></div></a></div><div class="card"> <a href="/posts/social-login-app/"><div class="card-body"> <em class="timeago small" date="2022-01-03 00:00:00 -0500" >Jan 3, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Writing a React Native App using Expo and Google Social Login</h3><div class="text-muted small"><p> This will be a brief tutorial on how to write a React Native application, using Expo, that implements Social Authentication, using Google. We will use ExpressJS and Passport in the backend to manag...</p></div></div></a></div><div class="card"> <a href="/posts/from-zero-to-data-ready-part-4/"><div class="card-body"> <em class="timeago small" date="2021-06-18 00:00:00 -0500" >Jun 18, 2021</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>From Zero to Data-Ready (Part 4): Building Analytics Dashboards using CubeJS and React</h3><div class="text-muted small"><p> In Part 3 we wrote our ETLs using Python and TDD. In this post we will focus on building an analytics platform for the company using CubeJS. What is CubeJS ? CubeJS is a tool that serves as a bac...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/from-zero-to-data-ready-part-4/" class="btn btn-outline-primary" prompt="Older"><p>From Zero to Data-Ready (Part 4): Building Analytics Dashboards using CubeJS and React</p></a> <a href="/posts/social-login-app/" class="btn btn-outline-primary" prompt="Newer"><p>Writing a React Native App using Expo and Google Social Login</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/sebasgarcep">Sebastian Garrido</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/data-engineering/">Data Engineering</a> <a class="post-tag" href="/tags/from-zero-to-data-ready/">From Zero to Data-Ready</a> <a class="post-tag" href="/tags/retail-project/">Retail Project</a> <a class="post-tag" href="/tags/mathematics/">Mathematics</a> <a class="post-tag" href="/tags/postgres/">Postgres</a> <a class="post-tag" href="/tags/python/">Python</a> <a class="post-tag" href="/tags/rust/">Rust</a> <a class="post-tag" href="/tags/sql/">SQL</a> <a class="post-tag" href="/tags/cubejs/">CubeJS</a> <a class="post-tag" href="/tags/data-assimilation/">Data Assimilation</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
